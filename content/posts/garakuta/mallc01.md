+++
title = "malloc은 사드세요 제발 (1)"
date = "2025-01-14T11:05:52Z"
author = "sayoon"
tags = ["뭐했더라"]
keywords = ["malloc", "메모리 구조"]
description = "malloc 구현 사전 준비"
showFullContent = false
readingTime = false
hideComments = false
+++

> `malloc` 구현의 두 가지 과제
> 1. 메모리 공간 확보 방식
> 2. 메모리 블록 관리 방식

<br/>

## 1. 메모리 공간 확보 방식

1) `sbrk` 시스템 콜
	- `POSIX` 계열에서 사용되었음
	- 힙 포인터를 증가시켜 메모리를 할당 받음
	- 구현이 간단하지만, *반환하는 것이 힘들다!*

2) `mmap` 시스템 콜
	- `page`[^1] 단위로 메모리 매핑 가능
	- 큰 메모리를 할당하거나, 재사용이 빈번하지 않은 경우 사용  

[^1]: `page`: `OS` 가 관리하는 `고정 크기` 메모리 단위 일반적으로 `4kb`  

⇒ 작은 단위에선 `sbrk`를, 큰 단위에선 `mmap`을 혼용하는 방식이 사용된다

<br/>

## 2. 메모리 블록 관리 방식

`mmap`으로 할당받은 메모리를 재활용할지, 즉시 `munmap`으로 반환할지는 내부 구현에 따라 다르다
   
> `mmap`과 같은 시스템콜을 자주 호출한다면   
> 1. **커널 모드로 전환**이 자주 일어나서 성능의 저하
> 2. 메모리 단편화 문제  
> 가 발생한다

그래서 보통은 `free`를 호출하더라도, 즉시 반환하지 않고 저장해 뒀다가 다시 사용하곤 한다   
이를 통해 얻을 수 있는 이점은 
1. 단편화 최소화: 필요한 경우 인접한 빈 블록을 하나로 병합해 반환함으로써 단편화를 최소화
2. 빠른 할당: 매번 `mmap`으로 할당하는 것 보다 빠르게 할당 가능 (`Hash`, `Segregated Free Tree` 등 사용)

<br/>

### 1) Segegated Free 방식
- 메모리 블록을 **요청 크기 별**로 나누어 관리하는 방법  
	예로
	- `small`: ~ 16byte
	- `medium`: 17 ~ 64byte
	- `large`: 65 ~ 256byte   
	...   
	와 같이 사용자가 반환한 빈 블록들을 따로 모아 크기별로 저장해놓는 것  
⇒ 이것을 저장할 때, `glibc`에서는 `tree bin`이라는 균형 트리(휴리스틱적인 로직 사용)를 이용한다

[계속...](/posts/garakuta/malloc02)
