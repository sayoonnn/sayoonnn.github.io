---
layout: post
title: OSI 7계층
category: web
---

## OSI 7계층

### 1. 애플리케이션

- 특정 애플리케이션에 특화된 프로토콜
    
    `SMTP(메일)`, `FTP(파일 전송)` …
    

### 2. 프리젠테이션

- 기기 고유의 데이터 포맷과 네트워크 공통의 데이터 포맷 교환
- 컴퓨터 또는 소프트웨어의 고유 형식 → 네트워크 전체에서 통일된 형식
- 부호화 방식을 식별하기 위한 헤더를 붙임
- 데이터를 전송하는 처리는 **세션층 이하**

### 3. 세션

- 통신 관리, 커넥션 확립 및 끊기를 언제 수행할지
- 트랜스포트 이하의 층 관리
- 어떻게 하면 효율적으로 데이터를 주고 받을 수 있을지, 어떤 방식으로 보낼지

### 4. 트랜스포트

- 실제 네트워크를 이용하여 데이터 송수신
- 데이터 전송의 신뢰성을 제공
- 실제 커넥션 확립 및 끊기 수행, 호스트 간 통신수단 제공

### 5. 네트워크층
- 송수신 처리
- IP, MAC 이용
- ip에서는 데이터의 신뢰성을 보장하지 않는다
- 올바르게 데이터를 처리하는 것은 트랜스포트층에서

### 6. 데이터링크 층
- 직접 연결된 기기 간의 데이터 프레임의 식별 및 전송

### 7. 물리 계층
- 0, 1 전압 또는 빛의 점멸, 커넥터 케이블 모양


<br/>

## TCP/IP

1. 하드웨어(물리층)
    - 이더넷, 전화회선 같은 물리층
    - 내용에 대해서는 아무것도 정해진 것이 없다 -> 네트워크 통신은 이루어진다는 것을 전제로
2. 네트워크 인터페이스 층(데이터 링크)
3. 인터넷층(네트워크층)
    - IP 프로토콜을 사용
    - ICMP(internet control message protocol): ip패킷의 배송중 이상이 생기면 에러 전송
    - ARP: ip 주로소 부터 물리적 주소(Mac)를 구하는 프로토콜
4. 트랜스포트층

---

> 이전 데이터 + 헤더를 붙이는 이유?
> 

수신 처리를 할 때, 헤더를 보고 상위 계층의 어떤 프로토콜을 사용할 것인지 결정해야하니까

<br/>
<br/>

# IP

<aside>
💡 데이터링크, 네트워크 두가지 계층이 존재하는 이유?

</aside>

- 데이터 링크는 직접 연결된 기기간의 통신
- IP를 통해 직접 연결되지 않은 두 기기간의 네트워크 통신

호스트 A →  라우터 A  → 라우터 B → 라우터 C →  호스트 B

           `이더넷`        `IP-VPN`   `기가비트 이더넷`  `ATM` 

- 데이터링크는 1홉(1구간) 통신
- 네트워크는 엔드 투 엔드

데이터링크 층에서는 전송 방식마다 **MTU**가 다름

`이더넷 1500옥텟` `FDDI 4352 옥텟` `ATM 9180 옥텟` 

IP는 최대 

IP는 분할처리(프래그멘테이션)을 통해서 여러개의 작은 패킷으로 나누어 전송

수신자는 이를 합쳐 하나의 패킷으로 인식

**데이터 링크의 특성을 추상화한다!**

<aside>
💡 클래스 형식 → 서브넷과 CIDR

</aside>

<aside>
💡 IPv6에서는 체크섬 헤더가 없다

</aside>

- TCP, UDP에서 확인가능 → segmentaion, fragmentation 개념 필요

### **MTU (Maximum Transmission Unit)**

MTU는 네트워크에서 한 번에 전송할 수 있는 데이터의 최대 크기를 나타냅니다. 이 크기는 네트워크의 물리적 또는 논리적 특성에 따라 결정됩니다. 예를 들어, Ethernet의 표준 MTU는 1500 바이트입니다. 이 한계를 넘는 데이터 패킷은 분할되어 전송되며, 수신 측에서 다시 조립됩니다. MTU의 크기는 성능과 효율성에 영향을 미칠 수 있습니다. 너무 작으면 패킷이 많이 생성되어 오버헤드가 증가하고, 너무 크면 네트워크를 통해 전송되지 않을 수 있습니다.

### **PMTUD (Path MTU Discovery)**

PMTUD는 송신자와 수신자 사이의 경로에 있는 모든 네트워크 세그먼트의 MTU를 고려하여 가장 큰 패킷 크기를 결정하는 프로토콜입니다. 이 과정은 인터넷 프로토콜(IP)을 사용하는 모든 네트워크 장치에서 작동합니다. PMTUD는 송신자가 패킷을 처음 보낼 때 'Don't Fragment (DF)' 비트를 설정함으로써 시작됩니다. 패킷이 너무 크면, 중간 라우터가 이를 폐기하고 ICMP (Internet Control Message Protocol) 메시지를 송신자에게 보내어 경로의 MTU를 줄여야 함을 알립니다. 이 정보를 바탕으로 송신자는 패킷 크기를 조정하고, 데이터 전송을 재시도합니다. PMTUD를 통해 네트워크의 효율성을 최적화하고 데이터 전송 실패를 줄일 수 있습니다.

## Fragmentation

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/98c015d1-def8-4399-931a-47453151ae6d/1fb6c5b1-4d83-46fa-a49d-e4d1770ebae6/Untitled.png)

- **`IP(3계층)`에서 발생**
- 출발 라우터에서 도착 라우터로 메세지를 라우팅 할때 데이터그램은 최대 패킷 크기가 데이터그램 크기보다 작은 네트워크를 통과해야 하고, 그렇기 때문에 이 과정에서 IP프로토콜이 Fragmentation이라는 기능을 제공한다.
- Encapsulation된 패킷이 수신자의 게이트 웨이를 통과할때 IP 헤더값의 데이터그램 크기를 확인 및 MTU값을 검증하는 과정에서 일어나고, 이때 해당 장비에서 ICMP패킷을 보내 MTU값에 데이터그램 크기를 맞춘 후 재전송 한다.
- 또한 단편화는 라우터에서 일어나지만, 재조립은 도착지 호스트에서 일어나게 된다.
- 단점
    1. 신뢰성 기반의 통신 방식이기 때문에 통신 과정에서 단편화된 패킷 중 하나가 유실되었을 때 중간에 어느 단편화된 패킷이 유실되었는지의 확인이 어렵다.
    2. 유실된 패킷을 포함해 재전송하는 데에 많은 리소스와 시간이 소요된다.
    
    → MTU를 넘지 않도록 `segmentation`을 이용해서 전송
    

## Segmentaion

**MSS :** 클라이언트와 서버간에 TCP 통신 시 최대로 전송할 수 있는 TCP 세그먼트의 크기를 의미한다. 3웨이 핸드쉐이크 과정에서 SYN, SYN-ACK 패킷의 option헤더에 이 값을 명시하게 된다

- 클라이언트는 자신의 MSS과 라우터의 MTU값을 비교하고, 그 중 낮은 값으로 MSS를 설정하여 SYN을 전송한다.
- 서버는 클라이언트로부터 수신한 MSS를 자신의 아웃바운드 인터페이스의 MTU사이즈-40바이트와 크기를 비교한다.
- 자신의 아웃바운드 인터페이스의 MTU사이즈와 수신된 MSS값을 비교 후 작은 값으로 설정하여 SYN-ACK을 전송한다.
- 클라이언트는 서버로부터 수신한 MSS와 자신의 아웃바운드 인터페이스의 MTU사이즈를 비교한다.
- 클라이언트는 상호 간의 MSS를 비교 후 작은 값으로 설정한다.

**PMTUD(Path MTU Discovery**

그냥 보내다가 fragmentaion이 걸리면? 라우터에 부하가 많이 걸리게 된다. 패킷 손실문제도 있다.

1. 호스트가 먼저 패킷을 전송하게 된다.
2. 작은 MTU값인 장비를 만나게 되면, 장비는 ICMP패킷을 이용해 수정을 요청하는 MTU값과 함께 다시 최초 전송자에게 요청한다.
3. 최초 전송자는 수정 요청된 MTU값에 맞게 데이터 크기를 조정하고 재전송하여 초과하지 않도록 한다.
4. 만약 라우팅 경로가 바뀐다면, 작은 패킷을 전송하는 것은 낭비가 됨으로 PMTU의 값을 주기적으로 1씩 증가시켜 전송하고 증가한 값이 또 다시 초과하게 되면 그때 1~3의 과정을 반복한다.

장비 관점에서 Segmentation은 라우터, 원천지 호스트 둘 다에서 일어난다. 앞서 확인했던 MSS, PMTUD과정에서 호스트, 장비간의 Segment를 조정하는 과정을 확인했고 이러한 과정 자체가 세그멘테이션이기 때문에 두 장비에서 모두 일어난다.

재조립은 동일하게 대상 **호스트에서 재조립된다.**

그럼 fragmentation은 왜 사용하냐? 

- 모든 경로를 탐색하면 트래픽이 많다??
- 대부분 1500이다 (이더넷)
- MTU가 큰 값에는 사용할 필요도 없다. 더 작은 경우에만 쓰면 된다.

<aside>
💡 IP와 MAC 모두 필요할까

</aside>

- IP는 계층형, MAC은 아니니까..?

### TCP

1. 시퀀스 번호 확인 응답
    - QUIC은 병렬적 처리 + 각 병렬 라인에 독립적인 패킷 번호 할당 ⇒ 유연한 처리 가능
2. 재전송 타임아웃
    - 일정 시간이 경과해도 확인응답이 없는 경우 데이터 재전송
    - RTT와 분산을 측정해서 설정
3. 커넥션 관리
    - 통신을 준비 후 통신 시작

> 3 way handshaking
> 
1. SYN (클라이언트 → 서버)
    - `SYN`, `SEQ = X`
2. SYN-ACK (서버 → 클라이언트)
    - `SYN`, `ACK`, `SEQ = Y`, `ACK = X+1`
3. ACK (클라이언트 → 서버)
    - `ACK`, `SEQ =  X + 1`, `ACK = Y + 1`

1. 세그먼트 단위 전송
    - MSS: IP에서 분할되지 않는 최대 데이터 길이
    - 3way handshaking 과정에서 송수신 호스트의 min 값으로
2. 슬라이딩 윈도우 제어
    - 패킷 왕복 시간이 길면, 자주 왕복수록 성능이 저하
    - 한번에 묶어서 보낸다!
    - 버퍼를 두고 더 큰단위로 확인 응답 처리
    - 확인 응답 기다리지 않고 송신할 수 있는 데이터 크기 `윈도우`
    - 버퍼에 윈도우로 쭉 저장하고, 응답을 받을 때마다 슬라이딩~
3. 고속 재전송 처리
    - 윈도 제어 하지 않는 경우, 응답을 받지 않으면 무조건 재전송 → 다음 응답 패킷을 확인함으로써 재전송 여부 판단 할 수 있음
    - 송신이 실패한 경우 중복된 확인 응답을 받게된다 3번 받으면 재전송??
4. 유량제어
    - 수신 측의 부하가 많이 걸려있을 경우 모두 수신하지 못할 가능성이 있다 → 지속적으로 재전송해야하므로 부하 상승
    - 수신 호스트가 송신 호스트에 수신 가능한 데이터 크기를 통지
    - 이 크기가 `윈도 사이즈` 헤더에 넣어 보낸다!
5. 혼잡제어
    - 한번에 많은 패킷을 보내면 혼잡!
    - `슬로우 스타트 알고리즘`
    - 혼잡 윈도우를 정의 하고, 1세그먼트씩 혼잡 윈도우를 늘려 나간다
    - 상대 호스트로부터 통지된 윈도우와 현재 혼잡 윈도우 비교
    - 제곱승으로 커지기 때문에 슬로 스타트 역치를 사용 → 역치를 넘은 경우 공식에 따라 증가
    - 타임아웃 나는 경우 1MSS 부터 시작
    - 항상 1MSS 부터 시작하는 것은 아니다 → 적절한 스루풋에 도달하기 까지 시간이 너무 오래 걸린다 이더넷의 경우 표준 1460byte 이므로 4380 부터 시작해도 된다???
    

그 밖의 알고리즘

1. Nagle
- 송신할 데이터가 있더라도 지연 송신
    1. 모든 송신 완료 데이터가 확인 응답된 경우
    2. 최대 MSS 의 데이터를 송신할 수 있는 경우
    
    에만 송신하게 된다
    

1. 지연 확인 응답
- 받는 즉시 반환 → 수신 버퍼 가득차거나, 작은 윈도우로 응답할 가능성
    - 2 X MSS 길이의 데이터를 수신할 때 까지 확인 응답 X
    - 또는 최대 0.5초간 지연시킨다
- 슬라이딩 윈도 제어 방식이므로, 확인 응답이 적어도 상관 X
- TCP 파일전송에서는 보통 2MSS 마다 확인 응답

1. 피기백
- FTP, SMTP 와 같은 경우 상대가 처리하여 대답 반환하는 경우 존재
- 이때, 확인 응답과 데이터를 함께 실어 보낸다
- 지연 확인 응답에 편승?
- 네트워크 효율 향상 + 컴퓨터 처리 부하 향상
